# 基于FPGA的Canny边缘检测算法的流式RTL实现

## 项目介绍

该项目旨在Intel CYCLONE-IV-E EP4CE115 FPGA上实现Canny边缘检测的核心算法。具体来说，Canny边缘检测算法是一种经典的计算机视觉算法，广泛应用于图像处理和目标检测领域。通过实现该算法的流式RTL版本，我们可以在FPGA上实现高速、低功耗的边缘检测，为图像处理应用提供更高的性能和效果。

在这个项目中，我实现了灰度处理和sobel滤波两个核心算法，首先将BMP位图灰度处理成8bit灰度图，给出亮度信息，并使用sobel算法求图像中的梯度向量，以此来量化像素亮度变化的剧烈程度，作为边缘的判断依据。

## 整体架构

输入是8位深彩色BMP位图，分辨率为720*540，在验证仿真时在软件层面上拆除BMP头，以RGB三个通道各8bit，每个像素共24bit，逐像素输入到待测模块中；输出则是8bit的灰度像素，在软件层面上额外加上BMP头，形成灰度图像

由于边缘检测的图像处理没有两帧之间的数据依赖，所以可以直接使用流式架构，通过FIFO进行不同子模块间的数据流传输，以此以单个像素为单位进行流式传输，加速整体计算

一共分为两个模块，24bit RGB像素在通过同步FIFO输入到top模块中后，输出到灰度处理模块，灰度处理模块输入24bit RGB像素，将RGB三个通道的强度值求平均，输出8bit的灰度像素。灰度处理模块通过FIFO和sobel滤波模块连接。sobel滤波模块中实现了一个长度为720*2+3=1443的8bit移位寄存器，用于实现对任意像素及其周围8个像素3\*3的梯度求解功能，求出梯度并进行限位后，作为8bit灰度像素经FIFO缓冲后输出

考虑到线性的数据流，整个模块使用唯一同步时钟以方便开发

## 功能特性

### 灰度处理模块

灰度处理模块内部是一个两状态的状态机，分为计算灰度和写FIFO两个状态，灰度像素值和状态机状态在always_ff块中在时钟上升沿更新

计算状态下，灰度值的计算是通过简化的方法进行的。如果前一级的FIFO空，没有待处理数据，则保持在计算状态继续等待。如果前一级的fifo非空，将RGB值的红、绿、蓝三个分量相加，然后除以3。计算时将8位颜色值扩展两位变为10位以避免溢出，并使用$unsigned调用将其强制为无符号数处理，计算结果截断为8位。直接在一个周期中进行三个分量的求和，并除3，并转移至写FIFO状态。

在写FIFO状态下，如果后一级的FIFO已满，则保持写FIFO状态等待，如果后一级的fifo未满，给出FIFO写使能信号，输出灰度值并切换回计算状态等待下一个输入像素就绪。

### Sobel求解模块

sobel模块中的移位寄存器长度可以通过传参来适应不同尺寸的图片

其算法的主干部分是，通过一个3\*3的梯度求解矩阵，将其中心遍历整张图片中非边界的所有像素，以求得图片中每个像素处的梯度。为了适应流式架构，使用了一个长度为图片中两行再加上3个像素的移位寄存器，并将其进行按时钟沿的缓冲更新，这样只需要逐位进行移位，就可以保证遍历到图片中的每一个像素，并求出该像素所在位置的梯度，作为边缘亮度信息。

具体来说，

## 性能表现

描述项目的性能表现，包括响应时间、吞吐量、资源利用率等指标。可以使用图表或数据表格来展示。

## 验证测试

描述项目的测试策略和质量保证措施，包括单元测试、集成测试和性能测试等。
